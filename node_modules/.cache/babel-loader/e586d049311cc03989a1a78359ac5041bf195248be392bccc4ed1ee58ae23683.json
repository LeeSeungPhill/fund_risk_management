{"ast":null,"code":"import { BaseComponentWrapper } from 'ag-grid-community';\nimport { VueComponentFactory } from './VueComponentFactory';\nexport class VueFrameworkComponentWrapper extends BaseComponentWrapper {\n  constructor(parent, provides) {\n    super();\n    this.parent = parent;\n    // when using master detail things provides to the master (like urlql) will not be available to the child components\n    // we capture the parent provides here (the first one will be the parent) - and re-use this when creating child components in VueComponentFactory\n    if (!VueFrameworkComponentWrapper.provides) {\n      VueFrameworkComponentWrapper.provides = provides;\n    }\n  }\n  createWrapper(component) {\n    const that = this;\n    class DynamicComponent extends VueComponent {\n      init(params) {\n        super.init(params);\n      }\n      hasMethod(name) {\n        const componentInstance = wrapper.getFrameworkComponentInstance();\n        if (!componentInstance[name]) {\n          return componentInstance.$.setupState[name] != null;\n        } else {\n          return true;\n        }\n      }\n      callMethod(name, args) {\n        var _a;\n        const componentInstance = this.getFrameworkComponentInstance();\n        const frameworkComponentInstance = wrapper.getFrameworkComponentInstance();\n        if (frameworkComponentInstance[name]) {\n          return frameworkComponentInstance[name].apply(componentInstance, args);\n        } else {\n          return (_a = frameworkComponentInstance.$.setupState[name]) === null || _a === void 0 ? void 0 : _a.apply(componentInstance, args);\n        }\n      }\n      addMethod(name, callback) {\n        wrapper[name] = callback;\n      }\n      overrideProcessing(methodName) {\n        return that.parent.autoParamsRefresh && methodName === 'refresh';\n      }\n      processMethod(methodName, args) {\n        if (methodName === 'refresh') {\n          this.getFrameworkComponentInstance().params = args[0];\n        }\n        if (this.hasMethod(methodName)) {\n          return this.callMethod(methodName, args);\n        }\n        return methodName === 'refresh';\n      }\n      createComponent(params) {\n        return that.createComponent(component, params);\n      }\n    }\n    const wrapper = new DynamicComponent();\n    return wrapper;\n  }\n  createComponent(component, params) {\n    return VueComponentFactory.createAndMountComponent(component, params, this.parent, VueFrameworkComponentWrapper.provides);\n  }\n  createMethodProxy(wrapper, methodName, mandatory) {\n    return function () {\n      if (wrapper.overrideProcessing(methodName)) {\n        return wrapper.processMethod(methodName, arguments);\n      }\n      if (wrapper.hasMethod(methodName)) {\n        return wrapper.callMethod(methodName, arguments);\n      }\n      if (mandatory) {\n        console.warn('AG Grid: Framework component is missing the method ' + methodName + '()');\n      }\n      return null;\n    };\n  }\n  destroy() {\n    this.parent = null;\n  }\n}\nclass VueComponent {\n  getGui() {\n    return this.element;\n  }\n  destroy() {\n    if (this.getFrameworkComponentInstance() && typeof this.getFrameworkComponentInstance().destroy === 'function') {\n      this.getFrameworkComponentInstance().destroy();\n    }\n    this.unmount();\n  }\n  getFrameworkComponentInstance() {\n    return this.componentInstance;\n  }\n  init(params) {\n    var _a;\n    const {\n      componentInstance,\n      element,\n      destroy: unmount\n    } = this.createComponent(params);\n    this.componentInstance = componentInstance;\n    this.unmount = unmount;\n    // the element is the parent div we're forced to created when dynamically creating vnodes\n    // the first child is the user supplied component\n    this.element = (_a = element.firstElementChild) !== null && _a !== void 0 ? _a : element;\n  }\n}","map":{"version":3,"names":["BaseComponentWrapper","VueComponentFactory","VueFrameworkComponentWrapper","constructor","parent","provides","createWrapper","component","that","DynamicComponent","VueComponent","init","params","hasMethod","name","componentInstance","wrapper","getFrameworkComponentInstance","$","setupState","callMethod","args","_a","frameworkComponentInstance","apply","addMethod","callback","overrideProcessing","methodName","autoParamsRefresh","processMethod","createComponent","createAndMountComponent","createMethodProxy","mandatory","arguments","console","warn","destroy","getGui","element","unmount","firstElementChild"],"sources":["/home/terra/Github/fund_risk_management/node_modules/ag-grid-vue3/lib/VueFrameworkComponentWrapper.js"],"sourcesContent":["import { BaseComponentWrapper } from 'ag-grid-community';\nimport { VueComponentFactory } from './VueComponentFactory';\nexport class VueFrameworkComponentWrapper extends BaseComponentWrapper {\n    constructor(parent, provides) {\n        super();\n        this.parent = parent;\n        // when using master detail things provides to the master (like urlql) will not be available to the child components\n        // we capture the parent provides here (the first one will be the parent) - and re-use this when creating child components in VueComponentFactory\n        if (!VueFrameworkComponentWrapper.provides) {\n            VueFrameworkComponentWrapper.provides = provides;\n        }\n    }\n    createWrapper(component) {\n        const that = this;\n        class DynamicComponent extends VueComponent {\n            init(params) {\n                super.init(params);\n            }\n            hasMethod(name) {\n                const componentInstance = wrapper.getFrameworkComponentInstance();\n                if (!componentInstance[name]) {\n                    return componentInstance.$.setupState[name] != null;\n                }\n                else {\n                    return true;\n                }\n            }\n            callMethod(name, args) {\n                var _a;\n                const componentInstance = this.getFrameworkComponentInstance();\n                const frameworkComponentInstance = wrapper.getFrameworkComponentInstance();\n                if (frameworkComponentInstance[name]) {\n                    return frameworkComponentInstance[name].apply(componentInstance, args);\n                }\n                else {\n                    return (_a = frameworkComponentInstance.$.setupState[name]) === null || _a === void 0 ? void 0 : _a.apply(componentInstance, args);\n                }\n            }\n            addMethod(name, callback) {\n                wrapper[name] = callback;\n            }\n            overrideProcessing(methodName) {\n                return that.parent.autoParamsRefresh && methodName === 'refresh';\n            }\n            processMethod(methodName, args) {\n                if (methodName === 'refresh') {\n                    this.getFrameworkComponentInstance().params = args[0];\n                }\n                if (this.hasMethod(methodName)) {\n                    return this.callMethod(methodName, args);\n                }\n                return methodName === 'refresh';\n            }\n            createComponent(params) {\n                return that.createComponent(component, params);\n            }\n        }\n        const wrapper = new DynamicComponent();\n        return wrapper;\n    }\n    createComponent(component, params) {\n        return VueComponentFactory.createAndMountComponent(component, params, this.parent, VueFrameworkComponentWrapper.provides);\n    }\n    createMethodProxy(wrapper, methodName, mandatory) {\n        return function () {\n            if (wrapper.overrideProcessing(methodName)) {\n                return wrapper.processMethod(methodName, arguments);\n            }\n            if (wrapper.hasMethod(methodName)) {\n                return wrapper.callMethod(methodName, arguments);\n            }\n            if (mandatory) {\n                console.warn('AG Grid: Framework component is missing the method ' + methodName + '()');\n            }\n            return null;\n        };\n    }\n    destroy() {\n        this.parent = null;\n    }\n}\nclass VueComponent {\n    getGui() {\n        return this.element;\n    }\n    destroy() {\n        if (this.getFrameworkComponentInstance() && typeof this.getFrameworkComponentInstance().destroy === 'function') {\n            this.getFrameworkComponentInstance().destroy();\n        }\n        this.unmount();\n    }\n    getFrameworkComponentInstance() {\n        return this.componentInstance;\n    }\n    init(params) {\n        var _a;\n        const { componentInstance, element, destroy: unmount } = this.createComponent(params);\n        this.componentInstance = componentInstance;\n        this.unmount = unmount;\n        // the element is the parent div we're forced to created when dynamically creating vnodes\n        // the first child is the user supplied component\n        this.element = (_a = element.firstElementChild) !== null && _a !== void 0 ? _a : element;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}